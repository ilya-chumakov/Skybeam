using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis.Text;

namespace Skybeam;

public static class PipelineTextEmitter
{
    public static readonly AssemblyName EmitterAssemblyName = typeof(PipelineTextEmitter).Assembly.GetName();
    public const string NamespacePrefix = "FancyGlobalPrefix";

    public static (SourceText text, PipelineDescription pd) CreateSourceText(
        HandlerDescription handler,
        IReadOnlyList<BehaviorDescription> behaviors)
    {
        // Operating over type names everywhere
        string inputType = handler.InputFullName;
        string outputType = handler.OutputFullName;
        string handlerType = handler.FullName;

        string pipelineNamespace = $"{NamespacePrefix}.{handler.ContainingNamespace}";
        string pipelineType = $"{handler.Name}Pipeline{handler.PipelineSuffix}";
        string targetFunc = "original";
        string interfaceType = "InterfaceAlias";
        string delegateType = "DelegateAlias";

        PipelineDescription pd = new
        (
            HandlerDescription: handler,
            FullName: $"global::{pipelineNamespace}.{pipelineType}"
        );

        using var sw = new StringWriter();
        using var writer = new IndentedTextWriter(sw, "    ");

        // Usings
        writer.WriteLine("using System;");
        writer.WriteLine("using System.Threading;");
        writer.WriteLine("using System.Threading.Tasks;");
        writer.WriteLine("using Microsoft.Extensions.DependencyInjection;");
        writer.WriteLine();
        writer.WriteLine("using Skybeam.Abstractions;");
        writer.WriteLine();
        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine($"namespace {pipelineNamespace};");
        writer.WriteLine();
        writer.WriteLine($"using {interfaceType} = IRequestHandler<");
        writer.Indent++;
        writer.WriteLine($"{inputType},");
        writer.WriteLine($"{outputType}>;");
        writer.Indent--;
        writer.WriteLine();
        writer.WriteLine($"using {delegateType} = RequestHandlerDelegate<");
        writer.Indent++;
        writer.WriteLine($"{outputType}>;");
        writer.Indent--;
        writer.WriteLine();
        writer.WriteLine($"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{EmitterAssemblyName.Name}\", \"{EmitterAssemblyName.Version}\")]");
        writer.WriteLine("[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Always)]");
        writer.WriteLine();

        // Class
        writer.WriteLine($"public class {pipelineType}(IServiceProvider provider) : {interfaceType}");
        writer.OpenBlock();

        // Method
        writer.WriteLine($"public Task<{outputType}> HandleAsync(");
        writer.Indent++;
        writer.WriteLine($"{inputType} input,");
        writer.WriteLine("CancellationToken ct = default)");
        writer.Indent--;
        writer.OpenBlock();

        // Handler creation
        writer.WriteLine($"var handler = provider.GetRequiredService<");
        writer.Indent++;
        writer.WriteLine($"{handlerType}>();");
        writer.Indent--;
        writer.WriteLine();
        writer.WriteLine($"{delegateType} {targetFunc} = () => handler.HandleAsync(input, ct);");
        writer.WriteLine();

        // Behaviors
        for (int i = 0; i < behaviors.Count; i++)
        {
            string currentFunc = $"f{i}";
            string currentBehavior = $"b{i}";
            string name = behaviors[i].FullNamePrefix;

            writer.WriteLine($"var {currentBehavior} = provider.GetRequiredService<");
            writer.Indent++;
            writer.WriteLine($"{name}<");
            writer.Indent++;
            writer.WriteLine($"{inputType},");
            writer.WriteLine($"{outputType}>>();");
            writer.Indent -= 2;
            writer.WriteLine();
            writer.WriteLine($"{delegateType} {currentFunc} = () => {currentBehavior}.HandleAsync(input, {targetFunc}, ct);");
            writer.WriteLine();

            targetFunc = currentFunc;
        }

        writer.WriteLine($"return {targetFunc}();");
        writer.CloseBlock();
        writer.CloseBlock(false);

        SourceText text = SourceText.From(sw.ToString(), Encoding.UTF8);
        return (text, pd);
    }
}
